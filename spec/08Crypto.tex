\chapter{Криптографическая поддержка}\label{CRYPTO}

\section{Эллиптические кривые}

Используются алгоритмы и протоколы 
на основе эллиптических кривых, описанных в СТБ 34.101.45 (подраздел 5.3). Во 
всех алгоритмах и протоколах используются параметры эллиптической кривой 
$p$, $a$, $b$, $q$ и $G$, заданные в СТБ 34.101.45 (приложение Б).
Этим параметрам в СТБ 34.101.45 (приложение Д) назначены идентификаторы
\texttt{bign-curve256v1} (уровень стойкости~$l=128$), 
\texttt{bign-curve384v1} ($l=192$), \texttt{bign-curve512v1} ($l=256$).

Параметры $p$, $a$ и $b$ определяют группу точек эллиптической
кривой~$E_{a,b}(\FF_p)$. Эта группа имеет порядок~$q$, ее элементами
являются аффинные точки, образующие множество $E_{a,b}^*(\FF_p)$, и
бесконечно удаленная точка. Параметр~$G$ (базовая точка) является
элементом~$E_{a,b}^*(\FF_p)$. Группа записывает аддитивно. Для натурального
числа~$u$ и аффинной точки~$V$ через~$uV$ обозначается сумма~$u$
экземпляров~$V$.

При передаче между сторонами точка~$V$ представляется 
словом~$\langle V\rangle_{4l}\in\{0,1\}^{4l}$. Правила представления заданы 
в СТБ~34.101.45 (пункт 4.1).

В алгоритмах и протоколах на основе эллиптических кривых используются 
личные и открытые ключи, долговременные или одноразовые. Личным ключом 
является число из множества~$\{1, 2,\ldots, q-1\}$, открытым ключом~--- 
элемент множества~$E_{a,b}^*(\FF_p)$.

\section{Стандартные криптографические алгоритмы}
\label{CRYPTO.StdAlg}

{\bf Алгоритм \texttt{belt-cfb}}.
Используется алгоритм зашифрования в режиме 
гаммирования с обратной связью, определенный в СТБ 34.101.31. 
Входными данными алгоритма являются сообщение $X\in\{0,1\}^*$, 
ключ $К\in\{0,1\}^{256}$ и синхропосылка $S\in\{0,1\}^{128}$.
Выходными данными является зашифрованное сообщение $Y\in\{0,1\}^{|X|}$.

{\bf Алгоритм $\texttt{belt-cfb}^{-1}$}.
Используется алгоритм расшифрования в режиме 
гаммирования с обратной связью, определенный в СТБ 34.101.31. 
Входными данными алгоритма являются зашифрованное 
сообщение $Y\in\{0,1\}^*$, ключ $K\in\{0,1\}^{256}$ 
и синхропосылка $S\in\{0,1\}^{128}$. Выходными 
данными является первоначальное сообщение $X\in\{0,1\}^{|Y|}$.

{\bf Алгоритм \texttt{belt-mac}}.
Используется алгоритм выработки имитовставки \texttt{belt-mac}, 
определенный в СТБ 34.101.31. Входными данными алгоритма 
являются сообщение $X\in\{0,1\}^*$ и ключ $K\in\{0,1\}^{256}$, 
выходными~--- имитовставка $T\in\{0,1\}^{64}$.

{\bf Алгоритм \texttt{belt-hash}}.
Используется алгоритм хэширования \texttt{belt-hash},
определенный в СТБ 34.101.31. Входными данными алгоритма 
является слово $X\in\{0,1\}^*$, выходными~--- 
его хэш-значение $Y\in\{0,1\}^{256}$.

{\bf Алгоритмы \texttt{bash384}, \texttt{bash512}}.
Используются алгоритмы хэширования \texttt{bash384}, \texttt{bash512},
определенные в СТБ 34.101.77. Входными данными алгоритмов
является слово $X\in\{0,1\}^*$, выходными~--- 
его хэш-значение $Y\in\{0,1\}^{384}$ или $Y\in\{0,1\}^{512}$.
%
КТ получает уже готовые хэш-значения и поэтому не должен реализовывать 
алгоритмы. 

{\bf Алгоритм \texttt{belt-keywrap}}.
Используется алгоритм устновки защиты ключа~\texttt{belt-keywrap}, 
определенный в СТБ 34.101.31. Входными данными алгоритма являются 
защищаемый ключ $X\in\{0,1\}^{8*}$, его заголовок $I\in\{0,1\}^{128}$, ключ 
защиты $K\in\{0,1\}^{256}$. 
Выходными данными является защищенный ключ $Y\in\{0,1\}^{|X|+128}$.

{\bf Алгоритм $\texttt{belt-keywrap}^{-1}$}.
Используется алгоритм снятия защиты ключа~$\texttt{belt-keywrap}^{-1}$, 
определенный в СТБ 34.101.31. Входными данными алгоритма являются 
защищенный ключ $Y\in\{0,1\}^{8*}$, заголовок $I\in\{0,1\}^{128}$, 
ключ защиты $K\in\{0,1\}^{256}$. Выходными данными является либо признак 
ошибки~$\perp$, либо первоначальный ключ $X\in\{0,1\}^{|Y|–128}$.

{\bf Алгоритм \texttt{belt-keyrep}}.
Используется алгоритм преобразования ключа 
\texttt{belt-keyrep}, определенный в СТБ 34.101.31.
Входными данными алгоритма являются преобразуемый ключ $X\in\{0,1\}^{256}$, 
уровень $D\in\{0,1\}^{96}$, заголовок $I\in\{0,1\}^{128}$, 
длина $m\in\{128,192,256\}$. Выходными данными 
является преобразованный ключ $Y\in\{0,1\}^{m}$.

{\bf Алгоритм \texttt{bign-genkeypair}}.
Используется алгоритм генерации пары ключей 
\texttt{bign-genkeypair}, определенный в СТБ 34.101.45.
Неявными входными данными алгоритма являются параметры эллиптической кривой.
В алгоритме используются случайные или псевдослучайные числа. 
Выходными данными алгоритма являются личный ключ $d\in\{1,2,\ldots,q-1\}$ 
и открытый ключ~$Q\in E_{a,b}^*(\FF_p)$.

{\bf Алгоритм \texttt{bign-valpubkey}}.
Используется алгоритм проверки открытого ключа 
\texttt{bign-valpubkey}, определенный в СТБ 34.101.45 (пункт 6.2.3). Входными 
данными алгоритма является открытый ключ $Q = (x_Q, y_Q)$, 
где $x_Q$, $y_Q$~--- целые числа. Выходными данными алгоритма является 
ответ~\texttt{ДА} ($Q$ является допустимым открытым ключом) или~\texttt{НЕТ}.

{\bf Алгоритм \texttt{bign-sign}}. Используется алгоритм выработки ЭЦП 
\texttt{bign-sign}, определенный в СТБ 34.101.45 с одним из алгоритмов
хэширования~\texttt{belt-hash} (на уровне стойкости $l=128$),
\texttt{bash384} ($l=192$) или \texttt{bash512} ($l=256$).
%
Входными данными~\texttt{bign-sign} являются сообщение 
$X\in\{0,1\}^*$ и личный ключ~$d\in\{1,2,\ldots,q-1\}$.
Выходными данными является подпись~$S\in\{0,1\}^{3l}$.

{\bf Алгоритм \texttt{bign-verify}}.
Используется алгоритм проверки ЭЦП \texttt{bign-verify}, 
определенный в СТБ 34.101.45 с одним из алгоритмов 
хэширования~\texttt{belt-hash} (на уровне стойкости $l=128$),  
\texttt{bash384} ($l=192$) или \texttt{bash512} ($l=256$). 
Входными данными \texttt{bign-verify} являются сообщение $X\in\{0,1\}^*$, 
подпись $S\in\{0,1\}^*$ и открытый ключ $Q \in E_{a,b}^*(\FF_p)$.
Выходными данными является ответ~\texttt{ДА} или~\texttt{НЕТ}.

{\bf Алгоритм \texttt{bign-keytransport}}.
Используется алгоритм создания токена ключа 
\texttt{bign-keytransport}, определенный в СТБ 34.101.45.
Входными данными алгоритма являются ключ $X\in\{0,1\}^{8*}$, 
его заголовок $I\in\{0,1\}^{128}$ и открытый ключ~$Q\in E_{a,b}^*(\FF p)$ 
получателя~$X$. Длина~$X$ должна быть не меньше~$128$.
Выходными данными является слово $Y\in\{0,1\}^{2l+|X|+128}$~--- токен ключа~$X$.
 
{\bf Алгоритм~$\texttt{bign-keytransport}^{-1}$}.
Используется алгоритм разбора токена ключа~$\texttt{bign-keytransport}^{-1}$, 
определенный в СТБ 34.101.45. Входными данными алгоритма являются токен 
$Y\in\{0,1\}^{8*}$, заголовок~$I\in\{0,1\}^{128}$ транспортируемого в нем ключа 
и личный ключ~$d\in\{1,2,\ldots,q-1\}$ получателя~$Y$.
Выходными данными является либо признак ошибки~$\perp$, 
либо слово~$X\in\{0,1\}^{|Y|-2l-128}$~--- ключ, 
который транспортируется в токене~$Y$.

{\bf Алгоритм \texttt{bake-kdf}}.
Используется алгоритм построения ключа~\texttt{bake-kdf}, 
определенный в СТБ 34.101.66 (пункт 6.1.3). Входными данными алгоритма 
являются секретное слово $X\in\{0,1\}^*$, 
дополнительное слово~$S\in\{0,1\}^*$ и номер ключа~$C$~--– 
неотрицательное целое число. Выходными данными является 
ключ~$Y\in\{0,1\}^{256}$.
 
\section{Протокол BPACE}\label{CRYPTO.BPACE}

\subsection{Общее описание}

Используется протокол формирования общего ключа BPACE, определенный в СТБ 
34.101.66 (пункт 7.6). Протокол выполняется между КТ и КП, при этом КТ 
выступает в роли стороны~$A$ (в обозначениях СТБ 34.101.66), а КП выступает 
в роли стороны~$B$.

Приветственное сообщение~$\hello_\text{КТ}$ 
($\hello_A$ в обозначениях СТБ 34.101.66) не используется, 
т.~е.является пустым словом. Соответственно не отправляется 
и не обрабатывается сообщение~M0. Приветственное сообщение~$\hello_\text{КП}$ 
не используется, либо отправляется перед выполнением протокола и поэтому 
сообщение~M1 содержит только зашифрованные данные~$Y_\text{КП}$ 
($Y_A$ в обозначениях СТБ 34.101.66). Даже не включенное явно в~M1 
сообщение~$\hello_\text{КП}$ должно использоваться при построении ключа.

При выполнении протокола КП и КТ должны подтверждать общий ключ, т.~е.
выполнять действия и передавать сообщения, помеченные в СТБ 34.101.66 
квадратными скобками. Подтверждая ключ, стороны проводят аутентификацию 
друг друга.

\subsection{Входные и выходные данные}

Входными данными протокола является приветственное 
сообщение~$\hello_\text{КП}\in\{0,1\}^*$ и пароль~$P\in\{0,1\}^{8*}$.
В качестве~$P$ могут выступать пароли PIN, CAN, PUK 
(см.~\ref{OBJ.PWD}}).

Выходными данными протокола является либо общий ключ $K_0\in\{0,1\}^{256}$, 
либо признак ошибки~$\perp$. Возврат~$\perp$ означает 
либо сбой при передаче сообщений протокола, либо нарушение целостности 
сообщений, либо нарушение их подлинности, либо ошибку аутентификации 
стороны протокола. Общий ключ~$K_0$ стороны используют для организации 
защищенного соединения.

\section{Протокол BAUTH}\label{CRYPTO.BAUTH}

\subsection{Общее описание}

Протокол BAUTH выполняется между КТ и терминалом. 
В описании протокола терминал обозначается буквой Т.
В ходе протокола стороны проводят аутентификацию друг друга и 
дополнительно формируют общий секретный ключ. Сначала КТ проверяет 
подлинность терминала, а затем терминал проверяет  
подлинность КТ. Аутентификация КТ перед терминалом может не выполняться, 
соответствующие сообщения и действия сторон окаймляются квадратными 
скобками.

Протокол BAUTH должен выполняться после парольной аутентификации с 
помощью протокола BPACE.

\subsection{Долговременные ключи}

Стороны протокола используют долговременные личные ключи~$d_\text{Т}$, 
$d_\text{КТ}\in\{1,2,\ldots,q-1\}$ и соответствующие открытые ключи~$Q_\text{Т}$, 
$Q_\text{КТ}\in E_{a,b}^*(\FF_p)$.
Для генерации пар ключей должен использоваться алгоритм~\texttt{bign-genkeypair}.

При хранении и распространении должны обеспечиваться конфиденциальность и 
контроль целостности личных ключей, контроль целостности открытых ключей.
Личные ключи~$d_\text{Т}$, $d_\text{КТ}$ должны использоваться только в 
протоколе BAUTH. Ключи могут дополнительно использоваться в алгоритмах 
ЭЦП, определенных в СТБ~34.101.45, например, для проверки владения личным 
ключом при формировании сертификатов, как это описано в~\ref{CERTS}.
Использование личных ключей в других алгоритмах и протоколах запрещено.

Открытые ключи распространяются как части 
сертификатов~$\Cert(Id_\text{Т},Q_\text{Т})$, 
$\Cert(Id_\text{КТ},Q_\text{КТ})$. При выполнении протокола сертификаты 
проверяются. Правила управления сертификатами и их проверки описаны 
в~\ref{CERTS}. 

Протокол простроен так, что терминал получает 
сертификат~$\Cert(Id_\text{КТ},Q_\text{КТ})$,  
только предъявляя действительный сертификат~$\Cert(Id_\text{Т},Q_\text{Т})$ 
и владея соответствующим личным ключом~$d_\text{Т}$.

\subsection{Входные и выходные данные}

Входными данными протокола являются приветственные сообщения 
$\hello_\text{Т},\hello_\text{КТ}\in\{0, 1\}^*$, 
личные ключи $d_\text{Т}$, $d_\text{КТ}$ и сертификаты 
$\Cert(Id_\text{Т}, Q_\text{Т})$, 
$\Cert(Id_\text{КТ}, Q_\text{КТ})$.

Выходными данными протокола является либо общий ключ $K_0 \in \{0, 1\}^{256}$, 
либо признак ошибки~$\perp$. Возврат~$\perp$ означает 
либо сбой при передаче сообщений протокола, либо нарушение целостности 
сообщений, либо нарушение их подлинности, либо ошибку аутентификации 
стороны протокола. Общий ключ $K_0$ является дополнительным результатом 
аутентификации, этот ключ стороны используют для организации защищенного 
соединения.

\subsection{Переменные}\label{CRYPTO.BAUTH.Vars}

{\bf Одноразовые личный и открытый ключи}.
КТ генерирует одноразовые личный ключ 
$u_\text{КТ}\in\{1, 2,\ldots,q-1\}$ и соответствующий открытый 
ключ~$V_\text{КТ} \in E_{a,b}^*(\FF_p)$. Ключ $V_\text{КТ}$ 
пересылается терминалу. Ключ $u_\text{КТ}$ должен быть уничтожен после 
использования. 

{\bf Одноразовый секретный ключ}.
КТ генерирует и пересылает терминалу одноразовый 
секретный ключ $R_\text{КТ}\in\{0, 1\}^{128}$.
Ключ должен генерироваться в соответствии с требованиями~\ref{OBJ.RNG}.

{\bf Защищенный одноразовый ключ}.
Ключ $R_\text{КТ}$ защищается с помощью алгоритма 
\texttt{belt-keywrap} и пересылается в виде 
слова~$Y_\text{КТ}\in\{0,1\}^{256}$.

{\bf Служебный ключ~$K$}.
Для защиты~$R_\text{КТ}$ используется служебный 
ключ~$K\in\{0,1\}^{256}$, который строится по личному и открытому 
ключам противоположных сторон. Ключ~$K$ должен быть уничтожен после 
использования.

{\bf Одноразовая подпись}.
Для аутентификации КТ перед терминалом используется 
одноразовая подпись $s_\text{КТ}\in\{0, 1,\ldots,q-1\}$.

{\bf Зашифрованные данные}.
КТ пересылает терминалу одноразовую подпись и свой 
сертификат в зашифрованном виде. Результатом зашифрования является слово 
$Z_\text{КТ}\in\{0,1\}^*$.

{\bf Синхропосылка}.
При аутентификации КТ перед терминалом используется синхропосылка 
$R_\text{Т}\in\{0,1\}^{128}$. В различных сеансах протокола терминал должен 
вырабатывать либо заведомо различные синхропосылки, либо вероятность 
совпадения синхропосылок должна быть пренебрежимо мала. Синхропосылки могут 
вырабатываться случайным или псевдослучайным методом, строиться по меткам 
времени, значениям монотонного счетчика и др.

{\bf Имитовставки}. Для аутентификации терминала перед КТ используется 
имитовставка $T_\text{Т}\in\{0,1\}^{64}$. Для контроля целостности 
зашифрованных данных используется 
имитовставка~$T_\text{КТ}\in\{0,1\}^{64}$. 

{\bf Служебный ключ $K_1$}.
Для вычисления имитовставок используется служебный ключ 
$K_1 \in\{0,1\}^{256}$. Ключ должен быть уничтожен после использования.

{\bf Служебный ключ $K_2$}.
Для шифрования одноразовой подписи и сертификата 
используется служебный ключ $K_2\in\{0,1\}^{256}$.
Ключ должен быть уничтожен после использования.

{\bf Переменная $t$}.
Используется переменная $t\in\{0,1\}^{128}$.

\subsection{Сообщения}

Стороны пересылают друг другу следующие сообщения:

M0 ($\text{Т}\to\text{КТ}$): 
$\mathimplicit{\hello_\text{Т}\parallel}\ 
\Cert(Id_\text{Т}, Q_\text{Т})$;

M1 ($\text{КТ}\to\text{Т}$): 
$\mathimplicit{\hello_\text{КТ}\parallel}\ 
\langle V_\text{КТ}\rangle_{512}\parallel Y_\text{КТ}$;

M2 ($\text{Т}\to\text{КТ}$): 
$T_\text{Т}\ \mathoptional{\parallel R_\text{Т}}$;

M3 ($\text{КТ}\to\text{Т}$): 
$\mathoptional{Z_\text{КТ}\parallel T_\text{КТ}}$.

\subsection{Шаги}

Аутентификация состоит в выполнении шагов, определенных ниже. При 
ошибке на любом из шагов, в том числе при отрицательном результате любой 
проверки, протокол прекращается и возвращается признак ошибки~$\perp$.

\begin{enumerate}
\item Т:
\begin{enumerate}
\item
\implicit{отправляет сообщение M0}.
\end{enumerate}
\item КТ:
\begin{enumerate}
\item
\implicit{получает сообщение M0};
\item
\implicit{проверяет~$\Cert(Id_\text{Т}, Q_\text{Т})$};
\item 
$R_\text{КТ}\stackrel{R}\gets\{0,1\}^{128}$ 
(в соответствии с требованиями~\ref{CRYPTO.BAUTH.Vars});
\item
$(u_\text{КТ}, V_\text{КТ})\gets\texttt{bign-genkeypair}()$;
\item
$K\gets\langle u_\text{КТ}Q_\text{Т}\rangle_{256}$;
\item
$Y_\text{КТ}\gets\texttt{belt-keywrap}(R_\text{КТ}, 0^{128}, K)$;
\item 
отправляет сообщение M1.
\end{enumerate}
\item Т:
\begin{enumerate}
\item
получает сообщение M1;
\item
проверяет, что $\texttt{bign-valpubkey}(V_\text{КТ}) = \texttt{ДА}$;
\item
$K\gets\langle d_\text{Т}V_\text{КТ}\rangle_{256}$;
\item
$R_\text{КТ}\gets\texttt{belt-keywrap}^{-1}(Y_\text{КТ}, 0^{128}, K)$;
\item
\optional{$R_\text{Т}\stackrel{R}\gets\{0,1\}^{128}$ 
(в соответствии с требованиями~\ref{CRYPTO.BAUTH.Vars})};
\item
$K_0\gets\texttt{bake-kdf}(R_\text{КТ},
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 0)$;
\item
$K_1\gets\texttt{bake-kdf}(R_\text{КТ}, 
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 1)$;
\item
$\mathoptional{K_2\gets\texttt{bake-kdf}(R_\text{КТ}, R_\text{Т}\parallel
\hello_\text{Т}\parallel\hello_\text{КТ}, 2)}$;
\item
$T_\text{Т}\gets\texttt{belt-mac}(0^{128}, K_1)$;
\item
отправляет сообщение M2.
\end{enumerate}
\item КТ:
\begin{enumerate}
\item
получает сообщение M2; 
\item
$K_0\gets\texttt{bake-kdf}(R_\text{КТ}, 
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 0)$;
\item
$K_1\gets\texttt{bake-kdf}(R_\text{КТ},
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 1)$;
\item
проверяет, что $T_\text{Т} = \texttt{belt-mac}(0^{128}, K_1)$;
\item
\optional{$K_2\gets\texttt{bake-kdf}(R_\text{КТ}, R_\text{Т}\parallel
\hello_\text{Т}\parallel\hello_\text{КТ}, 2)$};
\item
\optional{$t \gets \langle\texttt{belt-hash}(\langle V_\text{КТ}\rangle_{256}\parallel
R_\text{Т})\rangle_{128}$};
\item
\optional{$s_\text{КТ} \gets (u_\text{КТ}-(2^{l} + \bar{t} )d_\text{КТ}) \bmod q$}; 
\item
\optional{$Z_\text{КТ}\gets\texttt{belt-cfb}(\langle s_\text{КТ}\rangle_{256}
\parallel\Cert(Id_\text{КТ}, Q_\text{КТ}), K_2, 0^{128})$};
\item
\optional{$T_\text{КТ}\gets\texttt{belt-mac}(Z_\text{КТ}, K_1)$};
\item
\optional{отправляет сообщение M3}.
\end{enumerate}
\item[[5] Т:
\begin{enumerate}
\item
получает сообщение M3;
\item
проверяет, что $T_\text{КТ} = \texttt{belt-mac}(Z_\text{КТ}, K_1)$;
\item
$\langle s_\text{КТ}\rangle_{256}\parallel\Cert(Id_\text{КТ}, Q_\text{КТ}) 
\gets \texttt{belt-cfb}^{-1}(Z_\text{КТ}, K_2, 0^{128})$;
\item
проверяет, что $s_{КТ} \in\{0, 1,\ldots, q-1\}$;
\item
проверяет $\Cert(Id_\text{КТ}, Q_\text{КТ})$;
\item
$t\gets\langle\texttt{belt-hash}(\langle V_\text{КТ}\rangle_{256}\parallel
R_\text{Т})\rangle_{128}$;
\item
проверяет, что $s_\text{КТ}G + (2^{l} + \bar{t} )Q_\text{КТ} = V_\text{КТ}$].
\end{enumerate}
\end{enumerate}

Успешное выполнение шагов протокола означает, что КТ провел аутентификации 
терминала, \optional{терминал провел аутентификацию КТ,} и дополнительно 
стороны выработали общий ключ $K_0$.

\section{Защищенное соединение}\label{CRYPTO.SM}

\subsection{Общее описание}

Защищенное соединение обеспечивает защиту сообщений, передаваемых между КП 
и КТ или терминалом и КТ. Защита означает обеспечение конфиденциальности сообщений 
и контроль их целостности и подлинности. Ко всем отсылаемым сообщениям 
применяется алгоритм установки защиты, а ко всем входящим сообщениям~--- 
алгоритм снятия защиты.

Инициатором отправки сообщений всегда выступает КП или терминал.
Сообщение от этих сторон к КТ является частью некоторой команды, 
описанной в~\ref{CMDS}. 
Обратное сообщение от КТ является частью ответа на команду.

\subsection{Ключи защиты}

Для защиты сообщений используется ключ $K_0\in\{0,1\}^{256}$, по которому строятся 
ключи $K_1, K_2 \in\{0,1\}^{256}$. Ключ $K_1$ используется для имитозащиты, 
ключ $K_2$~--- для шифрования.

Алгоритм построения ключей шифрования и имитозащиты состоит из следующих шагов:

\begin{enumerate}
\item
Установить 
$K_1\gets\texttt{belt-keyrep}(K_0, 0^{96}, \langle 1 \rangle_{128}, 256)$.

\item
Установить 
$K_2\gets\texttt{belt-keyrep}(K_0, 0^{96}, \langle 2 \rangle_{128}, 256)$.

\item
Возвратить $(K_1, K_2)$.
\end{enumerate}

Ключи $K_0$, $K_1$, $K_2$ должны быть уничтожены при закрытии соединения.

\subsection{Счетчик}\label{CRYPTO.SM.Ctr}

Стороны соединения используют переменную-счетчик $C$, которая принимает 
неотрицательные целые значения. При создании соединения счетчик 
полагается равным~$0$.

КП и терминал используют слово $\langle C + 1 \rangle_{128}$ в качестве 
синхропосылки при зашифровании исходящих (и предназначенных КТ) сообщений. 
Соответственно, КТ использует слово $\langle C + 1 \rangle_{128}$ для 
расшифрования входящих сообщений. Обратно, КТ использует $\langle C + 2 
\rangle_{128}$ для зашифрования исходящих (и предназначенных КП или 
терминалу) сообщений. Соответственно, КП и терминал используют $\langle C + 2 
\rangle_{128}$ для расшифрования входящих сообщений. 

КП и терминал после отправки-приема сообщений и КТ после приема-отправки 
увеличивают значение $C$ на 2: $C\gets C + 2$.

\doubt{todo: Есть два защищенных соединения: между КТ и КП, между КТ и терминалом.
При создании второго защищенного соединения ключ и счетчик для первого должны сохраняться,
так как возможно переключение со второго соединения на первое. В свою очередь,
при переключении со второго соединения на первое ключ и счетчик второго должны сохраняться,
так как возможно обратное переключение с первого на второе.
}


\subsection{Алгоритмы защиты}\label{CRYPTO.SM.Algs}

\subsubsection{Входные и выходные данные, переменные}
\label{CRYPTO.SM.Algs.InOut}

Входными данными алгоритма установки защиты являются заголовок~$I\in\{0,1\}^{8*}$, 
критическое сообщение $X \in\{0,1\}^{8*}$, 
ключи $K_1$, $K_2\in\{0,1\}^{256}$ и 
синхропосылка $S\in\{0,1\}^{128}$.
Выходными данными является кодовое представление 
$\langle\langle I, Y, T \rangle\rangle$
заголовка~$I$, зашифрованного сообщения $Y \in\{0,1\}^{8*}$ 
и имитовставки $T \in {0,1}^{64}$.

Входными данными алгоритма снятия защиты является кодовое представление 
$\langle\langle I, Y, T\rangle\rangle$ заголовка $I$, зашифрованного 
сообщения $Y \in\{0,1\}^{8*}$ и имитовставки $T \in\{0, 1\}^{64}$, а также 
ключи $K_1$, $K_2 \in\{0,1\}^{256}$ и синхропосылка $S \in\{0,1\}^{128}$. 
Выходными данными является либо признак ошибки~$\perp$, либо первоначальное 
сообщение~$X\in\{0,1\}^{8*}$. Возврат~$\perp$ означает нарушение целостности 
или подлинности переданных данных.

Синхропосылки алгоритмов установки и снятия защиты строятся по правилам, 
определенным в~\ref{CRYPTO.SM.Ctr}. Правила кодирования выходных и 
промежуточных данных определены в~\ref{CMDS.SM}.

\subsubsection{Алгоритм установки защиты}
\label{CRYPTO.SM.Algs.Encr}

Алгоритм установки защиты состоит в выполнении шагов, определенных ниже.
При ошибке на любом из шагов алгоритм прекращается и возвращается признак 
ошибки~$\perp$.

\begin{enumerate}
\item
Установить $Y\gets\texttt{belt-cfb}(X, K_2, S)$.

\item
Выполнить кодирование $I$, $Y$ и построить их кодовое 
представление $\langle\langle I, Y\rangle\rangle$.

\item
$T\gets\texttt{belt-mac}(\langle\langle I, Y \rangle\rangle, K_1)$.

\item
Выполнить кодирование $I$, $Y$, $T$ и построить их кодовое 
представление $\langle\langle I, Y, T \rangle\rangle$.

\item
Возвратить $\langle\langle I, Y, T \rangle\rangle$.
\end{enumerate}

\subsubsection{Алгоритм снятия защиты}
\label{CRYPTO.SM.Algs.Decr}

Алгоритм снятия защиты состоит в выполнении шагов, определенных ниже. При 
ошибке на любом из шагов, в том числе при отрицательном результате 
проверки, алгоритм прекращается и возвращается признак ошибки~$\perp$.

\begin{enumerate}
\item
Выполнить декодирование $\langle\langle I, Y, T \rangle\rangle$ 
и определить $I$, $Y$, $T$.
 
\item
Выполнить кодирование $I$, $Y$ и построить их кодовое представление 
$\langle\langle I, Y \rangle\rangle$.
 
\item
Проверить, 
что $T=\texttt{belt-mac}(\langle\langle I, Y, T\rangle\rangle, K_1)$.
 
\item
$X\leftarrow\texttt{belt-cfb}^{-1}(Y, K_2, S)$.
 
\item
Возвратить $X$.
\end{enumerate}

\section{Структурированные данные}\label{CRYPTO.SignedEnveloped}

Криптографические алгоритмы могут выполняться в связке друг с другом для 
создания и разбора следующих структурированных данных.

{\bf Подписанные данные}.
Сообщение $X \in\{0, 1\}^*$ подписывается на личном ключе 
$d \in\{1, 2,\ldots, q-1\}$ с помощью алгоритма \texttt{bign-sign}.
Сообщение $X$ и подпись $S = \texttt{bign-sign}(X, d)$ кодируются, 
в результате чего получаются подписанные 
данные $\Signed(X, d) = \langle\langle X, S \rangle\rangle$.

Проверка подписанных данных выполняется с помощью алгоритма \texttt{bign-verify}.
При проверке кроме $X$ и $S$ используется открытый ключ $Q \in E_{a,b}^*(\FF_p)$, 
соответствующий $d$.

{\bf Конвертованные данные}.
Сообщение $X\in\{0,1\}^*$ зашифровывается на 
одноразовом секретном ключе $\theta\in\{0,1\}^{256}$, который вырабатывается в 
соответствии с требованиями СТБ 34.101.31 (подраздел 5.2) и уничтожается после 
использования. Шифрование выполняется с помощью алгоритма \texttt{belt-cfb}. При 
шифровании используется нулевая синхропосылка. После шифрования с помощью 
алгоритма \texttt{belt-keywrap} создается токен ключа $\theta$.
При создании токена $Y_1 = \texttt{bign-keytransport}(\theta, 0^{128}, Q)$ 
используется открытый ключ $Q \in E_{a,b}^*(\FF_p)$ получателя~$X$.

Шифртекст $Y_0 = \texttt{bign-cfb}(X, \theta, 0^{128})$ и токен ключа $Y_1$ 
кодируются, в результате чего получаются конвертованные данные 
$\Enveloped(X, Q) = \langle\langle Y_0, Y_1\rangle\rangle$.

Разбор конвертованных данных выполняется с помощью алгоритмов 
$\texttt{bign-keytransport}^{-1}$, $\texttt{belt-cfb}^{-1}$. Вначале c 
использованием личного ключа $d \in\{1, 2,\ldots, q-1\}$, 
соответствующего $Q$, определяется ключ 
$\theta = \texttt{bign-keytransport}^{-1}(Y_1, 0^{128}, d)$, 
при этом если алгоритм~$\texttt{bign-keytransport}^{-1}$ возвращает~$\perp$, 
то ключ~$\theta$ не определяется, а разбор конвертованных данных завершается с 
ошибкой. После нахождения $\theta$ определяется первоначальное сообщение 
$X = \texttt{belt-cfb}^{-1}(Y_0, \theta, 0^{128})$.

Ключ $\theta$ должен уничтожаться после использования.

