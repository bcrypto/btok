\chapter{Криптографическая поддержка}\label{CRYPTO}

\section{Эллиптические кривые}

Используются алгоритмы и протоколы 
на основе эллиптических кривых, описанных в СТБ 34.101.45 (пункт 5.3). Во 
всех алгоритмах и протоколах используются параметры эллиптической кривой 
$p$, $a$, $b$, $q$ и $G$, заданные в СТБ 34.101.45 (приложение Б).
Этим параметрам в СТБ 34.101.45 (приложение Д) назначены идентификаторы
\texttt{bign-curve256v1} (уровень стойкости~$l=128$), 
\texttt{bign-curve384v1} ($l=192$), \texttt{bign-curve512v1} ($l=256$).

Параметры $p$, $a$ и $b$ определяют группу точек эллиптической
кривой~$E_{a,b}(\FF_p)$. Эта группа имеет порядок~$q$, ее элементами
являются аффинные точки, образующие множество $E_{a,b}^*(\FF_p)$, и
бесконечно удаленная точка. Параметр~$G$ (базовая точка) является
элементом~$E_{a,b}^*(\FF_p)$. Группа записывает аддитивно. Для натурального
числа~$u$ и аффинной точки~$V$ через~$uV$ обозначается сумма~$u$
экземпляров~$V$.

При передаче между сторонами точка~$V$ представляется 
словом~$\langle V\rangle_{512}\in\{0,1\}^{512}$. Правила представления заданы 
в СТБ~34.101.45 (пункт 4.1).

В алгоритмах и протоколах на основе эллиптических кривых используются 
личные и открытые ключи, долговременные или одноразовые. Личным ключом 
является число из множества~$\{1, 2,\ldots, q-1\}$, открытым ключом~--- 
элемент множества~$E_{a,b}^*(\FF_p)$.

\section{Стандартные криптографические алгоритмы}
\label{CRYPTO.StdAlg}


{\bf Алгоритм \texttt{belt-cfb}}.
Используется алгоритм зашифрования в режиме 
гаммирования с обратной связью, определенный в СТБ 34.101.31 (пункт 
6.4.3). Входными данными алгоритма являются сообщение $X\in\{0,1\}^*$, 
ключ $\theta\in\{0,1\}^{256}$ и синхропосылка $S\in\{0,1\}^{128}$.
Выходными данными является зашифрованное сообщение $Y\in\{0,1\}^{|X|}$.

{\bf Алгоритм $\texttt{belt-cfb}^{-1}$}.
Используется алгоритм расшифрования в режиме 
гаммирования с обратной связью, определенный в СТБ 34.101.31 (пункт 
6.4.4). Входными данными алгоритма являются зашифрованное 
сообщение $Y\in\{0,1\}^*$, ключ $\theta\in\{0,1\}^{256}$ 
и синхропосылка $S\in\{0,1\}^{128}$. Выходными 
данными является первоначальное сообщение $X\in\{0,1\}^{|Y|}$.

{\bf Алгоритм \texttt{belt-mac}}.
Используется алгоритм выработки имитовставки \texttt{belt-mac}, 
определенный в СТБ 34.101.31 (пункт 6.6.3). Входными данными алгоритма 
являются сообщение $X\in\{0,1\}^*$ и ключ $\theta\in\{0,1\}^{256}$, 
выходными~--- имитовставка $T\in\{0,1\}^{64}$.

{\bf Алгоритм \texttt{belt-hash}}.
Используется алгоритм хэширования \texttt{belt-hash},
определенный в СТБ 34.101.31 (пункт 6.9.3). Входными данными алгоритма 
является слово $X\in\{0,1\}^*$, выходными~--- 
его хэш-значение $Y\in\{0,1\}^{256}$.

{\bf Алгоритмы \texttt{bash384}, \texttt{bash512}}.
Используются алгоритмы хэширования \texttt{bash384}, \texttt{bash512},
определенные в СТБ 34.101.77. Входными данными алгоритма 
является слово $X\in\{0,1\}^*$, выходными~--- 
его хэш-значение $Y\in\{0,1\}^{384}$ или $Y\in\{0,1\}^{512}$.
%
\doubt{КТ не должен реализовывать алгоритмы. Они используются только в 
связке с алгоритмом~\texttt{bign-sign}}.

{\bf Алгоритм \texttt{belt-keywrap}}.
Используется алгоритм \texttt{belt-keywrap}, определенный в 
СТБ 34.101.31 (пункт 6.8.3). Входными данными алгоритма являются 
транспортируемый ключ $X\in\{0,1\}^{8*}$, 
заголовок $I\in\{0,1\}^{128}$, ключ защиты $\theta\in\{0,1\}^{256}$.
Выходными данными является защищенный ключ $Y\in\{0,1\}^{|X|+128}$.

{\bf Алгоритм $\texttt{belt-keywrap}^{-1}$}.
Используется алгоритм $\texttt{belt-keywrap}^{-1}$, определенный 
в СТБ 34.101.31 (пункт 6.8.4). Входными данными алгоритма являются 
защищенный ключ $Y\in\{0,1\}^*$, заголовок $I\in\{0,1\}^{128}$, 
ключ защиты $\theta\in\{0,1\}^{256}$. Выходными данными является либо признак 
\texttt{ОШИБКА}, либо транспортируемый ключ $X\in\{0,1\}^{|Y|–128}$.

{\bf Алгоритм \texttt{belt-keyrep}}.
Используется алгоритм преобразования ключа 
\texttt{belt-keyrep}, определенный в СТБ 34.101.31 (пункт 7.2.3).
Входными данными алгоритма являются преобразуемый ключ $X\in\{0,1\}^{256}$, 
уровень $D\in\{0,1\}^{96}$, заголовок $I\in\{0,1\}^{128}$, 
длина $m\in\{128,192,256\}$. Выходными данными 
является преобразованный ключ $Y\in\{0,1\}^{m}$.

{\bf Алгоритм \texttt{bign-genkeypair}}.
Используется алгоритм генерации пары ключей 
\texttt{bign-genkeypair}, определенный в СТБ 34.101.45 (пункт 6.2.2).
В алгоритме используются случайные или псевдослучайные числа. Выходными данными 
алгоритма являются личный ключ $d \in\{1,2,\ldots,q-1\}$ и открытый 
ключ~$Q\in E_{a,b}^*(\FF_p)$.

{\bf Алгоритм \texttt{bign-valpubkey}}.
Используется алгоритм проверки открытого ключа 
\texttt{bign-valpubkey}, определенный в СТБ 34.101.45 (пункт 6.2.3). Входными 
данными алгоритма является открытый ключ $Q = (x_Q, y_Q)$, 
где $x_Q$, $y_Q$~--- целые числа. Выходными данными алгоритма является 
ответ~\texttt{ДА} ($Q$ является допустимым открытым ключом) или~\texttt{НЕТ}.

{\bf Алгоритм \texttt{bign-sign}}. Используется алгоритм выработки ЭЦП 
\texttt{bign-sign}, определенный в СТБ 34.101.45 (пункт 7.1.3), с функцией 
хэширования, заданной алгоритмами~\texttt{belt-hash} (на уровне стойкости $l=128$),
\texttt{bash384} ($l=192$) или \texttt{bash512} ($l=256$).
Входными данными алгоритма \texttt{bign-sign} являются сообщение 
$X\in\{0,1\}^*$ и личный ключ~$d\in\{1,2,\ldots,q-1\}$.
Выходными данными является электронная цифровая подпись~$S\in\{0,1\}^{384}$.

{\bf Алгоритм \texttt{bign-verify}}.
Используется алгоритм проверки ЭЦП \texttt{bign-verify}, 
определенный в СТБ 34.101.45 (пункт 7.1.4) с функцией хэширования, 
заданной алгоритмом \texttt{belt-hash}. Входными данными алгоритма 
\texttt{bign-verify} являются сообщение $X\in\{0,1\}^*$, 
подпись $S\in\{0,1\}^*$ и открытый ключ $Q \in E_{a,b}^*(\FF_p)$.
Выходными данными является ответ \texttt{ДА} или \texttt{НЕТ}.

{\bf Алгоритм \texttt{bign-keytransport}}.
Используется алгоритм создания токена ключа 
\texttt{bign-keytransport}, определенный в СТБ 34.101.45 (пункт 7.2.3).
Входными данными алгоритма являются ключ $X\in\{0,1\}^{8*}$, 
его заголовок $I\in\{0,1\}^{128}$ и открытый ключ~$Q\in E_{a,b}^*(\FF p)$ 
получателя~$X$. Длина~$X$ должна быть не меньше~$128$.
Выходными данными является слово $Y\in\{0,1\}^{384+|X|}$~--- токен ключа~$X$.
 
{\bf Алгоритм~$\texttt{bign-keytransport}^{-1}$}.
Используется алгоритм разбора токена ключа~$\texttt{bign-keytransport}^{-1}$, 
определенный в СТБ 34.101.45 (пункт 7.2.4). Входными 
данными алгоритма являются токен $Y\in\{0,1\}^{8*}$, 
заголовок $I\in\{0,1\}^{128}$ транспортируемого в нем ключа 
и личный ключ $d\in\{1,2,\ldots,q-1\}$ получателя~$Y$.
Выходными данными является либо признак \texttt{ОШИБКА}, 
либо слово~$X\in\{0,1\}^{|Y|-384}$~--- ключ, 
который транспортируется в токене~$Y$.

{\bf Алгоритм \texttt{bake-kdf}}.
Используется алгоритм построения ключа~\texttt{bake-kdf}, 
определенный в СТБ 34.101.66 (пункт 6.1.3). Входными данными алгоритма 
являются секретное слово $X\in\{0,1\}^*$, 
дополнительное слово~$S\in\{0,1\}^*$ и номер ключа~$C$~--– 
неотрицательное целое число. Выходными данными является 
ключ~$Y\in\{0,1\}^{256}$.
 
\section{Протокол BPACE}\label{CRYPTO.BPACE}

\subsection{Общее описание}

Используется протокол формирования общего ключа BPACE, определенный в СТБ 
34.101.66 (пункт 7.6). Протокол выполняется между КТ и КП, при этом КТ 
выступает в роли стороны~$A$ (в обозначениях СТБ 34.101.66), а КП выступает 
в роли стороны~$B$.

Приветственное сообщение~$\hello_\text{КТ}$ 
($\hello_A$ в обозначениях СТБ 34.101.66) не используется, 
т.~е.является пустым словом. Соответственно не отправляется 
и не обрабатывается сообщение~M0. Приветственное сообщение~$\hello_\text{КП}$ 
не используется, либо отправляется перед выполнением протокола и поэтому 
сообщение~M1 содержит только зашифрованные данные~$Y_\text{КП}$ 
($Y_A$ в обозначениях СТБ 34.101.66). Даже не включенное явно в~M1 
сообщение~$\hello_\text{КП}$ должно использоваться при построении ключа.

При выполнении протокола КП и КТ должны подтверждать общий ключ, т.~е.
выполнять действия и передавать сообщения, помеченные в СТБ 34.101.66 
квадратными скобками. Подтверждая ключ, стороны проводят аутентификацию 
друг друга.

\subsection{Входные и выходные данные}

Входными данными протокола является приветственное 
сообщение~$\hello_\text{КП}\in\{0,1\}^*$ и пароль~$P\in\{0,1\}^{8*}$.
В качестве~$P$ могут выступать пароли PIN, CAN, PUK 
(см.~\ref{OBJ.PIN}~--- \ref{OBJ.PUK}).

Выходными данными протокола является либо общий ключ $K_0\in\{0,1\}^{256}$, 
либо признак~\texttt{ОШИБКА}. Возврат признака~\texttt{ОШИБКА} означает 
либо сбой при передаче сообщений протокола, либо нарушение целостности 
сообщений, либо нарушение их подлинности, либо ошибку аутентификации 
стороны протокола. Общий ключ~$K_0$ стороны используют для организации 
защищенного соединения.

\section{Протокол BAUTH}\label{CRYPTO.BAUTH}

\subsection{Общее описание}

Протокол BAUTH выполняется между КТ и терминалом. В ходе 
выполнения протокола стороны проводят аутентификацию друг друга и 
дополнительно формируют общий секретный ключ. Сначала КТ проверяет 
подлинность терминала, а затем терминал проверяет  
подлинность КТ. Аутентификация КТ перед терминалом может не выполняться, 
соответствующие сообщения и действия сторон окаймляются квадратными 
скобками.

Протокол BAUTH должен выполняться после парольной аутентификации с 
помощью протокола BPACE.

\doubt{
В описании протокола терминал обозначается буквой Т.}

\subsection{Долговременные ключи}

Стороны протокола используют долговременные личные ключи~$d_\text{Т}$, 
$d_\text{КТ}\in\{1,2,\ldots,q-1\}$ и соответствующие открытые ключи~$Q_\text{Т}$, 
$Q_\text{КТ}\in E_{a,b}^*(\FF_p)$.
Для генерации пар ключей должен использоваться алгоритм~\texttt{bign-genkeypair}.

При хранении и распространении должны обеспечиваться конфиденциальность и 
контроль целостности личных ключей, контроль целостности открытых ключей.
Личные ключи~$d_\text{Т}$, $d_\text{КТ}$ должны использоваться только в 
протоколе BAUTH. Ключи могут дополнительно использоваться в алгоритмах 
ЭЦП, определенных в СТБ~34.101.45, например, для проверки владения личным 
ключом при формировании сертификатов, как это описано в~\ref{CERTS}.
Использование личных ключей в других алгоритмах и протоколах запрещено.

Открытые ключи распространяются как части 
сертификатов~$\Cert(Id_\text{Т},Q_\text{Т})$, 
$\Cert(Id_\text{КТ},Q_\text{КТ})$. При выполнении протокола сертификаты 
проверяются. Правила управления сертификатами и их проверки~описаны в~\ref{CERTS}.

Протокол простроен так, что терминал получает 
сертификат~$\Cert(Id_\text{КТ},Q_\text{КТ})$,  
только предъявляя действительный сертификат~$\Cert(Id_\text{Т},Q_\text{Т})$ 
и владея соответствующим личным ключом~$d_\text{Т}$.

\subsection{Входные и выходные данные}

Входными данными протокола являются приветственные сообщения 
$\hello_\text{Т},\hello_\text{КТ}\in\{0, 1\}^*$, 
личные ключи $d_\text{Т}$, $d_\text{КТ}$ и сертификаты 
$\Cert(Id_\text{Т}, Q_\text{Т})$, 
$\Cert(Id_\text{КТ}, Q_\text{КТ})$.

Выходными данными протокола является либо общий ключ $K_0 \in \{0, 1\}^{256}$, 
либо признак \texttt{ОШИБКА}. Возврат признака \texttt{ОШИБКА} означает 
либо сбой при передаче сообщений протокола, либо нарушение целостности 
сообщений, либо нарушение их подлинности, либо ошибку аутентификации 
стороны протокола. Общий ключ $K_0$ является дополнительным результатом 
аутентификации, этот ключ стороны используют для организации защищенного 
соединения.

\subsection{Переменные}\label{CRYPTO.BAUTH.Vars}

{\bf Одноразовые личный и открытый ключи}.
КТ генерирует одноразовые личный ключ 
$u_\text{КТ}\in\{1, 2,\ldots,q-1\}$ и соответствующий открытый 
ключ~$V_\text{КТ} \in E_{a,b}^*(\FF_p)$. Ключ $V_\text{КТ}$ 
пересылается терминалу. Ключ $u_\text{КТ}$ должен быть уничтожен после 
использования. 

{\bf Одноразовый секретный ключ}.
КТ генерирует и пересылает терминалу одноразовый 
секретный ключ $R_\text{КТ}\in\{0, 1\}^{128}$.
Ключ должен вырабатываться без возможности 
предсказания и уничтожаться после использования. Для создания ключа может 
использоваться физический генератор случайных чисел, удовлетворяющий ТНПА, 
или алгоритм генерации псевдослучайных чисел, определенный в СТБ 34.101.47 
или в другом ТНПА. Входные данные алгоритма должны включать секретный ключ 
КТ и уникальную синхропосылку. Длина ключа алгоритма генерации должна быть 
не меньше 128.

{\bf Защищенный одноразовый ключ}.
Ключ $R_\text{КТ}$ защищается с помощью алгоритма 
\texttt{belt-keywrap} и пересылается в виде 
слова~$Y_\text{КТ}\in\{0,1\}^{256}$.

{\bf Служебный ключ~$\theta$}.
Для защиты~$R_\text{КТ}$ используется служебный 
ключ~$\theta\in\{0,1\}^{256}$, который строится по личному и открытому 
ключам противоположных сторон. Ключ~$\theta$ должен быть уничтожен после 
использования.

{\bf Одноразовая подпись}.
Для аутентификации КТ перед терминалом используется 
одноразовая подпись $s_\text{КТ}\in\{0, 1,\ldots,q-1\}$.

{\bf Зашифрованные данные}.
КТ пересылает терминалу одноразовую подпись и свой 
сертификат в зашифрованном виде. Результатом зашифрования является слово 
$Z_\text{КТ}\in\{0,1\}^*$.

{\bf Синхропосылка}.
Для аутентификации КТ перед терминалом используется синхропосылка 
$R_\text{Т}\in\{0,1\}^{128}$. В различных сеансах протокола терминалом должен 
вырабатывать либо заведомо различные синхропосылки, либо вероятность 
совпадения синхропосылок должна быть пренебрежимо мала. Синхропосылки могут 
вырабатываться случайным или псевдослучайным методом, строиться по меткам 
времени, значениям монотонного счетчика и др.

{\bf Имитовставки}. Для аутентификации терминалом перед КТ используется 
имитовставка $T_\text{Т}\in\{0,1\}^{64}$. Для контроля целостности 
зашифрованных данных используется 
имитовставка~$T_\text{КТ}\in\{0,1\}^{64}$. 

{\bf Служебный ключ $K_1$}.
Для вычисления имитовставок используется служебный ключ 
$K_1 \in\{0,1\}^{256}$. Ключ должен быть уничтожен после использования.

{\bf Служебный ключ $K_2$}.
Для шифрования одноразовой подписи и сертификата 
используется служебный ключ $K_2\in\{0,1\}^{256}$.
Ключ должен быть уничтожен после использования.

{\bf Переменная $t$}.
Используется переменная $t\in\{0,1\}^{128}$.

\subsection{Сообщения}

Стороны пересылают друг другу следующие сообщения:

M0 ($\text{Т}\to\text{КТ}$): 
$\mathimplicit{\hello_\text{Т}\parallel}\ 
\Cert(Id_\text{Т}, Q_\text{Т})$;

M1 ($\text{КТ}\to\text{Т}$): 
$\mathimplicit{\hello_\text{КТ}\parallel}\ 
\langle V_\text{КТ}\rangle_{512}\parallel Y_\text{КТ}$;

M2 ($\text{Т}\to\text{КТ}$): 
$T_\text{Т}\ \mathoptional{\parallel R_\text{Т}}$;

M3 ($\text{КТ}\to\text{Т}$): 
$\mathoptional{Z_\text{КТ}\parallel T_\text{КТ}}$.

\subsection{Шаги}

Аутентификация состоит в выполнении шагов, определенных ниже. При 
ошибке на любом из шагов, в том числе при отрицательном результате любой 
проверки, протокол прекращается и возвращается признак \texttt{ОШИБКА}.

\begin{enumerate}
\item Т:
\begin{enumerate}
\item
\implicit{отправляет сообщение M0}.
\end{enumerate}
\item КТ:
\begin{enumerate}
\item
\implicit{получает сообщение M0};
\item
\implicit{проверяет~$\Cert(Id_\text{Т}, Q_\text{Т})$};
\item 
$R_{КТ}\stackrel{R}\gets\{0,1\}^{128}$ 
(в соответствии с требованиями~\ref{CRYPTO.BAUTH.Vars});
\item
$(u_\text{КТ}, V_\text{КТ})\gets\texttt{bign-genkeypair}()$;
\item
$\theta\gets\langle u_\text{КТ}Q_\text{Т}\rangle_{256}$;
\item
$Y_\text{КТ}\gets\texttt{bign-keytransport}(R_\text{КТ}, 0^{128}, K)$;
\item 
отправляет сообщение M1.
\end{enumerate}
\item Т:
\begin{enumerate}
\item
получает сообщение M1;
\item
проверяет, что $\texttt{bign-valpubkey}(V_\text{КТ}) = \texttt{ДА}$;
\item
$\theta\gets\langle d_\text{CИ}V_\text{КТ}\rangle_{256}$;
\item
$R_\text{КТ}\gets\texttt{belt-keywrap}^{-1}(Y_\text{КТ}, 0^{128}, K)$;
\item
\optional{$R_\text{Т}\stackrel{R}\gets\{0,1\}^{128}$ 
(в соответствии с требованиями~\ref{CRYPTO.BAUTH.Vars})};
\item
$K_0\gets\texttt{bake-kdf}(R_\text{КТ},
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 0)$;
\item
$K_1\gets\texttt{bake-kdf}(R_\text{КТ}, 
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 1)$;
\item
$\mathoptional{K_2\gets\texttt{bake-kdf}(R_\text{КТ}, R_\text{Т}\parallel
\hello_\text{Т}\parallel\hello_\text{КТ}, 2)}$;
\item
$T_\text{Т}\gets\texttt{belt-mac}(0^{128}, K_1)$;
\item
отправляет сообщение M2.
\end{enumerate}
\item КТ:
\begin{enumerate}
\item
получает сообщение M2; 
\item
$K_0\gets\texttt{bake-kdf}(R_\text{КТ}, 
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 0)$;
\item
$K_1\gets\texttt{bake-kdf}(R_\text{КТ},
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 1)$;
\item
проверяет, что $T_\text{Т} = \texttt{belt-mac}(0^{128}, K_1)$;
\item
\optional{$K_2\gets\texttt{bake-kdf}(R_\text{КТ}, R_\text{Т}\parallel
\hello_\text{Т}\parallel\hello_\text{КТ}, 2)$};
\item
\optional{$t \gets \langle\texttt{belt-hash}(\langle V_\text{КТ}\rangle_{256}\parallel
R_\text{Т})\rangle_{128}$};
\item
\optional{$s_\text{КТ} \gets (u_\text{КТ}-(2^{128} + \bar{t} )d_\text{КТ}) \bmod q$}; 
\item
\optional{$Z_\text{КТ}\gets\texttt{belt-cfb}(\langle s_\text{КТ}\rangle_{256}
\parallel\Cert(Id_\text{КТ}, Q_\text{КТ}), K_2, 0^{128})$};
\item
\optional{$Т_\text{КТ}\gets\texttt{belt-mac}(Z_\text{КТ}, K_1, 0^{128})$};
\item
\optional{отправляет сообщение M3}.
\end{enumerate}
\item[[5] Т:
\begin{enumerate}
\item
получает сообщение M3;
\item
проверяет, что $Т_\text{КТ} = \texttt{belt-mac}(Z_\text{КТ}, K_1, 0^{128})$;
\item
$\langle s_\text{КТ}\rangle_{256}\parallel\Cert(Id_\text{КТ}, Q_\text{КТ}) 
\gets \texttt{bake-cfb}^{-1}(Z_\text{КТ}, K_2, 0^{128})$;
\item
проверяет, что $s_{КТ} \in\{0, 1,\ldots, q-1\}$;
\item
проверяет $\Cert(Id_\text{КТ}, Q_\text{КТ})$;
\item
$t\gets\langle\texttt{belt-hash}(\langle V_\text{КТ}\rangle_{256}\parallel
R_\text{Т})\rangle_{128}$;
\item
проверяет, что $s_\text{КТ}G + (2^{128} + \bar{t} )Q_\text{КТ} = V_\text{КТ}$].
\end{enumerate}
\end{enumerate}

Успешное выполнение шагов протокола означает, что КТ провел аутентификации 
терминала, \optional{терминал провел аутентификацию КТ,} и дополнительно 
стороны выработали общий ключ $K_0$.

\section{Защищенное соединение}\label{CRYPTO.SM}

\subsection{Общее описание}

Защищенное соединение обеспечивает защиту сообщений, передаваемых между КП 
и КТ или терминалом и КТ. Защита означает обеспечение конфиденциальности сообщений 
и контроль их целостности и подлинности. Ко всем отсылаемым сообщениям 
применяется алгоритм установки защиты, а ко всем входящим сообщениям~--- 
алгоритм снятия защиты.

Инициатором отправки сообщений всегда выступает КП или терминал.
Сообщение от этих сторон к КТ является частью некоторой команды, 
описанной в~\ref{CMDS}. Обратное сообщение от КТ является частью ответа на 
команду.

\subsection{Ключи защиты}

Для защиты сообщений используется ключ $K\in\{0,1\}^{256}$, по которому строятся 
ключи $K_1, K_2 \in\{0,1\}^{256}$. Ключ $K_1$ используется для имитозащиты, 
ключ $K_2$~--- для шифрования.

Алгоритм построения ключей шифрования и имитозащиты состоит из следующих шагов:

\begin{enumerate}
\item
Установить 
$K_1\gets\texttt{belt-keyrep}(K, 0^{96}, \langle 1 \rangle_{128}, 256)$.

\item
Установить 
$K_2\gets\texttt{belt-keyrep}(K, 0^{96}, \langle 2 \rangle_{128}, 256)$.

\item
Возвратить $(K_1, K_2)$.
\end{enumerate}

Ключи $K$, $K_1$, $K_2$ должны быть уничтожены при закрытии соединения.

\subsection{Счетчик}\label{CRYPTO.SM.Ctr}

Стороны соединения используют переменную-счетчик $C$, которая принимает 
неотрицательные целые значения. При создании соединения счетчик 
полагается равным~$0$.

КП и терминал используют слово $\langle C + 1 \rangle_{128}$ в качестве 
синхропосылки при зашифровании исходящих (и предназначенных КТ) сообщений. 
Соответственно, КТ использует слово $\langle C + 1 \rangle_{128}$ для 
расшифрования входящих сообщений. Обратно, КТ использует $\langle C + 2 
\rangle_{128}$ для зашифрования исходящих (и предназначенных КП или 
терминалу) сообщений. Соответственно, КП и терминал используют $\langle C + 2 
\rangle_{128}$ для расшифрования входящих сообщений. 

КП и терминал после отправки-приема сообщений и КТ после приема-отправки 
увеличивают значение $C$ на 2: $C\gets C + 2$.

\subsection{Алгоритмы защиты}\label{CRYPTO.SM.Algs}

\subsubsection{Входные и выходные данные, переменные}
\label{CRYPTO.SM.Algs.InOut}

Входными данными алгоритма установки защиты являются заголовок~$I\in\{0,1\}^{8*}$, 
критическое сообщение $X \in\{0,1\}^{8*}$, 
ключи $K_1$, $K_2\in\{0,1\}^{256}$ и 
синхропосылка $S\in\{0,1\}^{128}$.
Выходными данными является кодовое представление 
$\langle\langle I, Y, T \rangle\rangle$
заголовка~$I$, зашифрованного сообщения $Y \in\{0,1\}^{8*}$ 
и имитовставки $T \in {0,1}^{64}$.

Входными данными алгоритма снятия защиты является кодовое представление 
$\langle\langle I, Y, T\rangle\rangle$ заголовка $I$, зашифрованного 
сообщения $Y \in\{0,1\}^{8*}$ и имитовставки $T \in\{0, 1\}^{64}$, а также 
ключи $K_1$, $K_2 \in\{0,1\}^{256}$ и синхропосылка $S \in\{0,1\}^{128}$. 
Выходными данными является либо признак \texttt{ОШИБКА}, либо 
первоначальное сообщение $X \in\{0,1\}^{8*}$. 
Возврат признака \texttt{ОШИБКА} означает нарушение целостности или 
подлинности переданных данных.

Синхропосылки алгоритмов установки и снятия защиты строятся по правилам, 
определенным в~\ref{CRYPTO.SM.Ctr}. 
Правила кодирования выходных и промежуточных данных определены в~\ref{CMDS.SM}.

\subsubsection{Алгоритм установки защиты}
\label{CRYPTO.SM.Algs.Encr}

Алгоритм установки защиты состоит в выполнении шагов, определенных ниже.
При ошибке на любом из шагов алгоритм прекращается и возвращается признак 
\texttt{ОШИБКА}.

\begin{enumerate}
\item
Установить $Y\gets\texttt{belt-cfb}(X, K_2, S)$.

\item
Выполнить кодирование $I$, $Y$ и построить их кодовое 
представление $\langle\langle I, Y\rangle\rangle$.

\item
$T\gets\texttt{belt-mac}(\langle\langle I, Y \rangle\rangle, K_1)$.

\item
Выполнить кодирование $I$, $Y$, $T$ и построить их кодовое 
представление $\langle\langle I, Y, T \rangle\rangle$.

\item
Возвратить $\langle\langle I, Y, T \rangle\rangle$.
\end{enumerate}

\subsubsection{Алгоритм снятия защиты}
\label{CRYPTO.SM.Algs.Decr}

Алгоритм снятия защиты состоит в выполнении шагов, определенных ниже. При 
ошибке на любом из шагов, в том числе при отрицательном результате 
проверки, алгоритм прекращается и возвращается признак \texttt{ОШИБКА}.

\begin{enumerate}
\item
Выполнить декодирование $\langle\langle I, Y, T \rangle\rangle$ 
и определить $I$, $Y$, $T$.
 
\item
Выполнить кодирование $I$, $Y$ и построить их кодовое представление 
$\langle\langle I, Y \rangle\rangle$.
 
\item
Проверить, 
что $T=\texttt{belt-mac}(\langle\langle I, Y, T\rangle\rangle, K_1)$.
 
\item
$X\leftarrow\texttt{belt-cfb}^{-1}(Y, K_2, S)$.
 
\item
Возвратить $X$.
\end{enumerate}

\section{Структурированные данные}\label{CRYPTO.SignedEnveloped}

Криптографические алгоритмы могут выполняться в связке друг с другом для 
создания и разбора следующих структурированных данных.

{\bf Подписанные данные}.
Сообщение $X \in\{0, 1\}^*$ подписывается на личном ключе 
$d \in\{1, 2,\ldots, q-1\}$ с помощью алгоритма \texttt{bign-sign}.
Сообщение $X$ и подпись $S = \texttt{bign-sign}(X, d)$ кодируются, 
в результате чего получаются подписанные 
данные $\Signed(X, d) = \langle\langle X, S \rangle\rangle$.

Проверка подписанных данных выполняется с помощью алгоритма \texttt{bign-verify}.
При проверке кроме $X$ и $S$ используется открытый ключ $Q \in E_{a,b}^*(\FF_p)$, 
соответствующий $d$.

{\bf Конвертованные данные}.
Сообщение $X\in\{0,1\}^*$ зашифровывается на 
одноразовом секретном ключе $\theta\in\{0,1\}^{256}$, который вырабатывается в 
соответствии с требованиями СТБ 34.101.31 (п.5.2) и уничтожается после 
использования. Шифрование выполняется с помощью алгоритма \texttt{belt-cfb}. При 
шифровании используется нулевая синхропосылка. После шифрования с помощью 
алгоритма \texttt{belt-keywrap} создается токен ключа $K$.
При создании токена $Y_1 = \texttt{bign-keytransport}(K, 0^{128}, Q)$ 
используется открытый ключ $Q \in E_{a,b}^*(\FF_p)$ получателя~$X$.

Шифртекст $Y_0 = \texttt{bign-cfb}(X, K, 0^{128})$ и токен ключа $Y_1$ 
кодируются, в результате чего получаются конвертованные данные 
$\Enveloped(X, Q) = \langle\langle Y_0, Y_1\rangle\rangle$.

Разбор конвертованных данных выполняется с помощью алгоритмов 
$\texttt{bign-keytransport}^{-1}$, $\texttt{belt-cfb}^{-1}$. Вначале c 
использованием личного ключа $d \in\{1, 2,\ldots, q-1\}$, 
соответствующего $Q$, определяется ключ 
$K = \texttt{bign-keytransport}^{-1}(Y_1, 0^{128}, d)$, 
при этом если алгоритм~$\texttt{bign-keytransport}^{-1}$ возвращает \texttt{ОШИБКА}, 
то ключ~$K$ не определяется, а разбор конвертованных данных завершается с 
ошибкой. После нахождения $K$ определяется первоначальное сообщение 
$X = \texttt{belt-cfb}^{-1}(Y_0, K, 0^{128})$.

Ключ $K$ должен уничтожаться после использования.

