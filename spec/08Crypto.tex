\chapter{Криптографическая поддержка}\label{CRYPTO}

\section{Эллиптические кривые}\label{CRYPTO.EC}

Для выработки и проверки ЭЦП, транспорта ключа и аутентификации используются 
алгоритмы и протоколы на основе эллиптических кривых, описанных в СТБ 
34.101.45.
%
Во всех алгоритмах и протоколах используются параметры эллиптической кривой 
$p$, $a$, $b$, $q$ и $G$, заданные в СТБ 34.101.45 (приложение Б).
Этим параметрам в СТБ 34.101.45 (приложение Д) назначены идентификаторы
\texttt{bign-curve256v1} (уровень стойкости~$l=128$), 
\texttt{bign-curve384v1} ($l=192$), \texttt{bign-curve512v1} ($l=256$).

Параметры $p$, $a$ и $b$ определяют группу точек эллиптической
кривой~$E_{a,b}(\FF_p)$. Эта группа имеет порядок~$q$, ее элементами
являются аффинные точки, образующие множество $E_{a,b}^*(\FF_p)$, и
бесконечно удаленная точка. Параметр~$G$ (базовая точка) является
элементом~$E_{a,b}^*(\FF_p)$. Группа записывает аддитивно. Для натурального
числа~$u$ и аффинной точки~$V$ через~$uV$ обозначается сумма~$u$
экземпляров~$V$.

При передаче между сторонами точка~$V$ представляется 
словом~$\langle V\rangle_{4l}\in\{0,1\}^{4l}$. Правила представления заданы 
в СТБ~34.101.45 (пункт 4.1).

В алгоритмах и протоколах на основе эллиптических кривых используются 
личные и открытые ключи, долговременные или одноразовые. Личным ключом 
является число из множества~$\{1, 2,\ldots, q-1\}$, открытым ключом~--- 
элемент множества~$E_{a,b}^*(\FF_p)$.

\section{Стандартные криптографические алгоритмы}
\label{CRYPTO.StdAlg}

{\bf Алгоритм \texttt{belt-cfb}}.
Используется алгоритм зашифрования в режиме 
гаммирования с обратной связью, определенный в СТБ 34.101.31. 
Входными данными алгоритма являются сообщение $X\in\{0,1\}^*$, 
ключ $К\in\{0,1\}^{256}$ и синхропосылка $S\in\{0,1\}^{128}$.
Выходными данными является зашифрованное сообщение $Y\in\{0,1\}^{|X|}$.

{\bf Алгоритм $\texttt{belt-cfb}^{-1}$}.
Используется алгоритм расшифрования в режиме 
гаммирования с обратной связью, определенный в СТБ 34.101.31. 
Входными данными алгоритма являются зашифрованное 
сообщение $Y\in\{0,1\}^*$, ключ $K\in\{0,1\}^{256}$ 
и синхропосылка $S\in\{0,1\}^{128}$. Выходными 
данными является первоначальное сообщение $X\in\{0,1\}^{|Y|}$.

{\bf Алгоритм \texttt{belt-mac}}.
Используется алгоритм выработки имитовставки \texttt{belt-mac}, 
определенный в СТБ 34.101.31. Входными данными алгоритма 
являются сообщение $X\in\{0,1\}^*$ и ключ $K\in\{0,1\}^{256}$, 
выходными~--- имитовставка $T\in\{0,1\}^{64}$.

{\bf Алгоритм \texttt{belt-hash}}.
Используется алгоритм хэширования \texttt{belt-hash},
определенный в СТБ 34.101.31. Входными данными алгоритма 
является слово $X\in\{0,1\}^*$, выходными~--- 
его хэш-значение $Y\in\{0,1\}^{256}$.

{\bf Алгоритмы \texttt{bash384}, \texttt{bash512}}.
Используются алгоритмы хэширования \texttt{bash384}, \texttt{bash512},
определенные в СТБ 34.101.77. Входными данными алгоритмов
является слово $X\in\{0,1\}^*$, выходными~--- 
его хэш-значение $Y\in\{0,1\}^{384}$ или $Y\in\{0,1\}^{512}$.
%
КТ может не реализовывать алгоритмы, если не предполагается проверка 
облегченных сертификатов (см. раздел~\ref{CERTS}), подписанных на ключах 
уровней стойкости~$l=192$ и~$l=256$.

{\bf Алгоритм \texttt{belt-keywrap}}.
Используется алгоритм установки защиты ключа~\texttt{belt-keywrap}, 
определенный в СТБ 34.101.31. Входными данными алгоритма являются 
защищаемый ключ $X\in\{0,1\}^{8*}$, его заголовок $I\in\{0,1\}^{128}$, ключ 
защиты $K\in\{0,1\}^{256}$. 
Выходными данными является защищенный ключ $Y\in\{0,1\}^{|X|+128}$.

{\bf Алгоритм $\texttt{belt-keywrap}^{-1}$}.
Используется алгоритм снятия защиты ключа~$\texttt{belt-keywrap}^{-1}$, 
определенный в СТБ 34.101.31. Входными данными алгоритма являются 
защищенный ключ $Y\in\{0,1\}^{8*}$, заголовок $I\in\{0,1\}^{128}$, 
ключ защиты $K\in\{0,1\}^{256}$. Выходными данными является либо признак 
ошибки~$\perp$, либо первоначальный ключ $X\in\{0,1\}^{|Y|-128}$.

{\bf Алгоритм \texttt{belt-keyrep}}.
Используется алгоритм преобразования ключа 
\texttt{belt-keyrep}, определенный в СТБ 34.101.31.
Входными данными алгоритма являются преобразуемый ключ $X\in\{0,1\}^{256}$, 
уровень $D\in\{0,1\}^{96}$, заголовок $I\in\{0,1\}^{128}$, 
длина $m\in\{128,192,256\}$. Выходными данными 
является преобразованный ключ $Y\in\{0,1\}^{m}$.

{\bf Алгоритм \texttt{bign-genkeypair}}.
Используется алгоритм генерации пары ключей 
\texttt{bign-genkeypair}, определенный в СТБ 34.101.45.
Неявными входными данными алгоритма являются параметры эллиптической кривой.
В алгоритме используются случайные или псевдослучайные числа. 
Выходными данными алгоритма являются личный ключ $d\in\{1,2,\ldots,q-1\}$ 
и открытый ключ~$Q\in E_{a,b}^*(\FF_p)$.

{\bf Алгоритм \texttt{bign-valpubkey}}.
Используется алгоритм проверки открытого ключа 
\texttt{bign-valpubkey}, определенный в СТБ 34.101.45 (пункт 6.2.3). Входными 
данными алгоритма является открытый ключ $Q = (x_Q, y_Q)$, 
где $x_Q$, $y_Q$~--- целые числа. Выходными данными алгоритма является 
ответ~\texttt{ДА} ($Q$ является допустимым открытым ключом) или~\texttt{НЕТ}.

{\bf Алгоритм \texttt{bign-sign}}. Используется алгоритм выработки ЭЦП 
\texttt{bign-sign}, определенный в СТБ 34.101.45 с одним из алгоритмов
хэширования~\texttt{belt-hash} (на уровне стойкости $l=128$),
\texttt{bash384} ($l=192$) или \texttt{bash512} ($l=256$).
%
Входными данными~\texttt{bign-sign} являются сообщение 
$X\in\{0,1\}^*$ и личный ключ~$d\in\{1,2,\ldots,q-1\}$.
Выходными данными является подпись~$S\in\{0,1\}^{3l}$.

{\bf Алгоритм \texttt{bign-verify}}.
Используется алгоритм проверки ЭЦП \texttt{bign-verify}, 
определенный в СТБ 34.101.45 с одним из алгоритмов 
хэширования~\texttt{belt-hash} (на уровне стойкости $l=128$),  
\texttt{bash384} ($l=192$) или \texttt{bash512} ($l=256$). 
Входными данными \texttt{bign-verify} являются сообщение $X\in\{0,1\}^*$, 
подпись $S\in\{0,1\}^*$ и открытый ключ $Q\in E_{a,b}^*(\FF_p)$.
Выходными данными является ответ~\texttt{ДА} или~\texttt{НЕТ}.

{\bf Алгоритм \texttt{bign-keytransport}}.
Используется алгоритм создания токена ключа 
\texttt{bign-keytransport}, определенный в СТБ 34.101.45.
Входными данными алгоритма являются ключ $X\in\{0,1\}^{8*}$, 
его заголовок $I\in\{0,1\}^{128}$ и открытый ключ~$Q\in E_{a,b}^*(\FF p)$ 
получателя~$X$. Длина~$X$ должна быть не меньше~$128$.
Выходными данными является слово $Y\in\{0,1\}^{2l+|X|+128}$~--- токен ключа~$X$.
 
{\bf Алгоритм~$\texttt{bign-keytransport}^{-1}$}.
Используется алгоритм разбора токена ключа~$\texttt{bign-keytransport}^{-1}$, 
определенный в СТБ 34.101.45. Входными данными алгоритма являются токен 
$Y\in\{0,1\}^{8*}$, заголовок~$I\in\{0,1\}^{128}$ транспортируемого в нем ключа 
и личный ключ~$d\in\{1,2,\ldots,q-1\}$ получателя~$Y$.
Выходными данными является либо признак ошибки~$\perp$, 
либо слово~$X\in\{0,1\}^{|Y|-2l-128}$~--- ключ, 
который транспортируется в токене~$Y$.

{\bf Алгоритм \texttt{bake-kdf}}.
Используется алгоритм построения ключа~\texttt{bake-kdf}, 
определенный в СТБ 34.101.66 (пункт 6.1.3). Входными данными алгоритма 
являются секретное слово $X\in\{0,1\}^*$, 
дополнительное слово~$S\in\{0,1\}^*$ и номер ключа~$C$~--– 
неотрицательное целое число. Выходными данными является 
ключ~$Y\in\{0,1\}^{256}$.
 
\section{Протокол BPACE}\label{CRYPTO.BPACE}

\subsection{Общее описание}

Для парольной аутентификации используется протокол формирования общего ключа 
BPACE, определенный в СТБ 34.101.66 (пункт 7.6). Протокол выполняется между КТ 
и КП, при этом КТ выступает в роли стороны~$A$ (в обозначениях СТБ 34.101.66), 
а КП~--- в роли стороны~$B$.

Приветственное сообщение~$\hello_\text{КТ}$ 
($\hello_A$ в обозначениях СТБ 34.101.66) не используется, 
т.~е. является пустым словом. Соответственно не отправляется 
и не обрабатывается сообщение~M0. Приветственное сообщение~$\hello_\text{КП}$ 
отправляется перед выполнением протокола и поэтому сообщение~M1 содержит только 
зашифрованные данные~$Y_\text{КП}$ ($Y_A$ в обозначениях СТБ 34.101.66). Даже 
не включенное явно в~M1 сообщение~$\hello_\text{КП}$ должно использоваться при 
построении ключа.

При выполнении протокола КП и КТ должны подтверждать общий ключ, т.~е.
выполнять действия и передавать сообщения, помеченные в СТБ 34.101.66 
квадратными скобками. Подтверждая ключ, стороны проводят аутентификацию 
друг друга.

\subsection{Входные и выходные данные}

Входными данными протокола является приветственное 
сообщение~$\hello_\text{КП}\in\{0,1\}^*$ и пароль~$P\in\{0,1\}^{8*}$.
В качестве~$P$ могут выступать пароли PIN, CAN, PUK 
(см.~\ref{OBJ.PWD}).

Выходными данными протокола является либо общий ключ $K_0\in\{0,1\}^{256}$, 
либо признак ошибки~$\perp$. Возврат~$\perp$ означает 
либо сбой при передаче сообщений протокола, либо нарушение целостности 
сообщений, либо нарушение их подлинности, либо ошибку аутентификации 
стороны протокола. Общий ключ~$K_0$ стороны используют для организации 
защищенного соединения.

\section{Протокол BAUTH}\label{CRYPTO.BAUTH}

\subsection{Общее описание}\label{CRYPTO.BAUTH.Intro}

Протокол BAUTH используется для взаимной аутентификации КТ и терминала. 
В описании протокола терминал обозначается буквой Т.
В ходе протокола стороны проводят аутентификацию друг друга и 
дополнительно формируют общий секретный ключ. Сначала КТ проверяет 
подлинность терминала, а затем терминал проверяет  
подлинность КТ. Аутентификация КТ перед терминалом может не выполняться, 
соответствующие сообщения и действия сторон окаймляются квадратными 
скобками.

Протокол BAUTH должен выполняться после парольной аутентификации с 
помощью протокола BPACE.

\subsection{Долговременные ключи}\label{CRYPTO.BAUTH.Keys}

Стороны протокола используют долговременные личные ключи~$d_\text{Т}$, 
$d_\text{КТ}\in\{1,2,\ldots,q-1\}$ и соответствующие открытые ключи~$Q_\text{Т}$, 
$Q_\text{КТ}\in E_{a,b}^*(\FF_p)$.
Для генерации пар ключей должен использоваться алгоритм~\texttt{bign-genkeypair}.

При хранении и распространении должны обеспечиваться конфиденциальность и 
контроль целостности личных ключей, контроль целостности открытых ключей.
Личные ключи~$d_\text{Т}$, $d_\text{КТ}$ дополнительно к протоколу BAUTH 
могут использоваться в алгоритмах ЭЦП, определенных в СТБ~34.101.45, 
для проверки владения личным ключом при формировании сертификатов. 
Использование личных ключей в других алгоритмах и протоколах запрещено.

Открытые ключи распространяются в виде 
сертификатов~$\Cert(Id_\text{Т},Q_\text{Т})$,  
$\Cert(Id_\text{КТ},Q_\text{КТ})$. При выполнении протокола сертификаты 
проверяются. Сертификат должен признаваться действительным, только если
корректны его формат, срок действия, подпись УЦ, выпустившего сертификат. 

Протокол построен так, что терминал получает 
сертификат~$\Cert(Id_\text{КТ},Q_\text{КТ})$,  
только предъявляя действительный сертификат~$\Cert(Id_\text{Т},Q_\text{Т})$ 
и владея соответствующим личным ключом~$d_\text{Т}$.

\subsection{Входные и выходные данные}\label{CRYPTO.BAUTH.InOut}

Входными данными протокола являются приветственные сообщения 
$\hello_\text{Т},\hello_\text{КТ}\in\{0, 1\}^*$, 
личные ключи $d_\text{Т}$, $d_\text{КТ}$ и сертификаты 
$\Cert(Id_\text{Т}, Q_\text{Т})$, 
$\Cert(Id_\text{КТ}, Q_\text{КТ})$.

Выходными данными протокола является либо общий ключ $K_0\in\{0,1\}^{256}$, 
либо признак ошибки~$\perp$. Возврат~$\perp$ означает 
либо сбой при передаче сообщений протокола, либо нарушение целостности 
сообщений, либо нарушение их подлинности, либо ошибку аутентификации 
стороны протокола. Общий ключ $K_0$ является дополнительным результатом 
аутентификации, этот ключ стороны используют для организации защищенного 
соединения.

\subsection{Переменные}\label{CRYPTO.BAUTH.Vars}

{\bf Одноразовые личный и открытый ключи}.
КТ генерирует одноразовые личный ключ 
$u_\text{КТ}\in\{1,2,\ldots,q-1\}$ и соответствующий открытый 
ключ~$V_\text{КТ}\in E_{a,b}^*(\FF_p)$. Ключ $V_\text{КТ}$ 
пересылается терминалу. Ключ $u_\text{КТ}$ должен быть уничтожен после 
использования. 

{\bf Одноразовый секретный ключ}.
КТ генерирует и пересылает терминалу одноразовый 
секретный ключ $R_\text{КТ}\in\{0,1\}^{l}$.
Ключ должен генерироваться в соответствии с требованиями~\ref{OBJ.RNG}.

{\bf Защищенный одноразовый ключ}.
Ключ $R_\text{КТ}$ защищается с помощью алгоритма 
\texttt{belt-keywrap} и пересылается в виде 
слова~$Y_\text{КТ}\in\{0,1\}^{l+128}$.

{\bf Служебный ключ~$K$}.
Для защиты~$R_\text{КТ}$ используется служебный 
ключ~$K\in\{0,1\}^{256}$, который строится по личному и открытому 
ключам противоположных сторон. Ключ~$K$ должен быть уничтожен после 
использования.

{\bf Одноразовая подпись}.
Для аутентификации КТ перед терминалом используется 
одноразовая подпись $s_\text{КТ}\in\{0,1,\ldots,q-1\}$.

{\bf Зашифрованные данные}.
КТ пересылает терминалу одноразовую подпись и свой 
сертификат в зашифрованном виде. Результатом зашифрования является слово 
$Z_\text{КТ}\in\{0,1\}^*$.

{\bf Синхропосылка}.
При аутентификации КТ перед терминалом используется синхропосылка 
$R_\text{Т}\in\{0,1\}^{128}$. В различных сеансах протокола терминал должен 
вырабатывать либо заведомо различные синхропосылки, либо вероятность 
совпадения синхропосылок должна быть пренебрежимо мала. Синхропосылки могут 
вырабатываться случайным или псевдослучайным методом, строиться по меткам 
времени, значениям монотонного счетчика и др.

{\bf Имитовставки}. Для аутентификации терминала перед КТ используется 
имитовставка $T_\text{Т}\in\{0,1\}^{64}$. Для контроля целостности 
зашифрованных данных используется 
имитовставка~$T_\text{КТ}\in\{0,1\}^{64}$. 

{\bf Служебный ключ $K_1$}.
Для вычисления имитовставок используется служебный ключ 
$K_1\in\{0,1\}^{256}$. Ключ должен быть уничтожен после использования.

{\bf Служебный ключ $K_2$}.
Для шифрования одноразовой подписи и сертификата 
используется служебный ключ $K_2\in\{0,1\}^{256}$.
Ключ должен быть уничтожен после использования.

{\bf Переменная $t$}.
Используется переменная~$t\in\{0,1\}^l$.

\subsection{Сообщения}\label{CRYPTO.BAUTH.Msgs}

Стороны пересылают друг другу следующие сообщения:

M0 ($\text{Т}\to\text{КТ}$): 
$\mathimplicit{\hello_\text{Т}\parallel}\ 
\Cert(Id_\text{Т}, Q_\text{Т})$;

M1 ($\text{КТ}\to\text{Т}$): 
$\mathimplicit{\hello_\text{КТ}\parallel}\ 
\langle V_\text{КТ}\rangle_{4l}\parallel Y_\text{КТ}$;

M2 ($\text{Т}\to\text{КТ}$): 
$T_\text{Т}\ \mathoptional{\parallel R_\text{Т}}$;

M3 ($\text{КТ}\to\text{Т}$): 
$\mathoptional{Z_\text{КТ}\parallel T_\text{КТ}}$.

\subsection{Шаги}\label{CRYPTO.BAUTH.Steps}

Аутентификация состоит в выполнении шагов, определенных ниже. При 
ошибке на любом из шагов, в том числе при отрицательном результате любой 
проверки, протокол прекращается и возвращается признак ошибки~$\perp$.

\begin{enumerate}
\item Т:
\begin{enumerate}
\item
\implicit{отправляет сообщение M0}.
\end{enumerate}
\item КТ:
\begin{enumerate}
\item
\implicit{получает сообщение M0};
\item
\implicit{проверяет~$\Cert(Id_\text{Т}, Q_\text{Т})$};
\item 
$R_\text{КТ}\stackrel{R}\gets\{0,1\}^l$ 
(в соответствии с требованиями~\ref{CRYPTO.BAUTH.Vars});
\item
$(u_\text{КТ}, V_\text{КТ})\gets\texttt{bign-genkeypair}()$;
\item
$K\gets\langle u_\text{КТ}Q_\text{Т}\rangle_{256}$;
\item
$Y_\text{КТ}\gets\texttt{belt-keywrap}(R_\text{КТ}, 0^{128}, K)$;
\item 
отправляет сообщение M1.
\end{enumerate}
\item Т:
\begin{enumerate}
\item
получает сообщение M1;
\item
проверяет, что $\texttt{bign-valpubkey}(V_\text{КТ}) = \texttt{ДА}$;
\item
$K\gets\langle d_\text{Т}V_\text{КТ}\rangle_{256}$;
\item
$R_\text{КТ}\gets\texttt{belt-keywrap}^{-1}(Y_\text{КТ}, 0^{128}, K)$;
\item
\optional{$R_\text{Т}\stackrel{R}\gets\{0,1\}^{128}$ 
(в соответствии с требованиями~\ref{CRYPTO.BAUTH.Vars})};
\item
$K_0\gets\texttt{bake-kdf}(R_\text{КТ},
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 0)$;
\item
$K_1\gets\texttt{bake-kdf}(R_\text{КТ}, 
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 1)$;
\item
$\mathoptional{K_2\gets\texttt{bake-kdf}(R_\text{КТ}, R_\text{Т}\parallel
\hello_\text{Т}\parallel\hello_\text{КТ}, 2)}$;
\item
$T_\text{Т}\gets\texttt{belt-mac}(0^{128}, K_1)$;
\item
отправляет сообщение M2.
\end{enumerate}
\item КТ:
\begin{enumerate}
\item
получает сообщение M2; 
\item
$K_0\gets\texttt{bake-kdf}(R_\text{КТ}, 
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 0)$;
\item
$K_1\gets\texttt{bake-kdf}(R_\text{КТ},
\mathoptional{R_\text{Т}\parallel}\ \hello_\text{Т}\parallel\hello_\text{КТ}, 1)$;
\item
проверяет, что $T_\text{Т} = \texttt{belt-mac}(0^{128}, K_1)$;
\item
\optional{$K_2\gets\texttt{bake-kdf}(R_\text{КТ}, R_\text{Т}\parallel
\hello_\text{Т}\parallel\hello_\text{КТ}, 2)$};
\item
\optional{$t\gets\langle\texttt{belt-hash}
(\langle V_\text{КТ}\rangle_{2l}\parallel R_\text{Т})\rangle_l$};
\item
\optional{$s_\text{КТ}\gets(u_\text{КТ}-(2^{l}+\btoi{t})d_\text{КТ})\bmod q$}; 
\item
\optional{$Z_\text{КТ}\gets\texttt{belt-cfb}(\langle s_\text{КТ}\rangle_{2l}
\parallel\Cert(Id_\text{КТ}, Q_\text{КТ}), K_2, 0^{128})$};
\item
\optional{$T_\text{КТ}\gets\texttt{belt-mac}(Z_\text{КТ}, K_1)$};
\item
\optional{отправляет сообщение M3}.
\end{enumerate}
\item[$\bigl[$5] Т:
\begin{enumerate}
\item
получает сообщение M3;
\item
проверяет, что $T_\text{КТ} = \texttt{belt-mac}(Z_\text{КТ}, K_1)$;
\item
$(\langle s_\text{КТ}\rangle_{2l}\parallel\Cert(Id_\text{КТ}, Q_\text{КТ})) 
\gets \texttt{belt-cfb}^{-1}(Z_\text{КТ}, K_2, 0^{128})$;
\item
проверяет, что $s_\text{КТ} \in\{0, 1,\ldots, q-1\}$;
\item
проверяет $\Cert(Id_\text{КТ}, Q_\text{КТ})$;
\item
$t\gets\langle\texttt{belt-hash}(\langle 
V_\text{КТ}\rangle_{2l}\parallel R_\text{Т})\rangle_{l}$;
\item
проверяет, что 
$s_\text{КТ}G + (2^{l} + \btoi{t})Q_\text{КТ} = V_\text{КТ}\bigr]$.
\end{enumerate}
\end{enumerate}

Успешное выполнение шагов протокола означает, что КТ провел аутентификацию 
терминала, \optional{терминал провел аутентификацию КТ,} и дополнительно 
стороны выработали общий ключ $K_0$.

\section{Защищенное соединение}\label{CRYPTO.SM}

\subsection{Общее описание}\label{CRYPTO.SM.Intro}

При функционировании КТ могут создаваться два защищенных соединения: <<КП~--- 
КТ>> и <<терминал~--- КТ>>. Защита означает обеспечение конфиденциальности 
передаваемых сообщений и контроль их целостности и подлинности. Ко всем 
отсылаемым сообщениям применяется алгоритм установки защиты, а ко всем входящим 
сообщениям~---  алгоритм снятия защиты.

Инициатором отправки сообщений всегда выступает КП или терминал.
Сообщение от этих сторон к КТ является частью некоторой команды, 
описанной в разделе~\ref{CMDS}. Обратное сообщение от КТ является частью ответа 
на команду.

\subsection{Ключи защиты}\label{CRYPTO.BAUTH.Keys}

Для защиты сообщений используется ключ $K_0\in\{0,1\}^{256}$, по которому строятся 
ключи $K_1, K_2 \in\{0,1\}^{256}$. Ключ $K_1$ используется для имитозащиты, 
ключ $K_2$~--- для шифрования.

Алгоритм построения ключей шифрования и имитозащиты состоит из следующих шагов:

\begin{enumerate}
\item
Установить 
$K_1\gets\texttt{belt-keyrep}(K_0, 0^{96}, \langle 1 \rangle_{128}, 256)$.

\item
Установить 
$K_2\gets\texttt{belt-keyrep}(K_0, 0^{96}, \langle 2 \rangle_{128}, 256)$.

\item
Возвратить $(K_1, K_2)$.
\end{enumerate}

Ключи $K_0$, $K_1$, $K_2$ должны быть уничтожены при закрытии соединения.

\subsection{Счетчик}\label{CRYPTO.SM.Ctr}

Стороны соединения используют переменную-счетчик $C$, которая принимает 
неотрицательные целые значения. При создании соединения счетчик 
полагается равным~$0$.

КП и терминал используют слово $\langle C + 1\rangle_{128}$ в качестве 
синхропосылки при зашифровании исходящих (и предназначенных КТ) сообщений. 
Соответственно, КТ использует слово $\langle C + 1\rangle_{128}$ для 
расшифрования входящих сообщений. Обратно, КТ использует 
$\langle C + 2\rangle_{128}$ для зашифрования исходящих (и предназначенных КП 
или терминалу) сообщений. Соответственно, КП и терминал используют 
$\langle C + 2\rangle_{128}$ для расшифрования входящих сообщений. 

КП и терминал после отправки-приема сообщений и КТ после приема-отправки 
увеличивают значение~$C$ на~$2$: $C\gets C + 2$.

При переключении с одного соединения на другое КТ должен сохранять ключи и 
счетчик текущего соединения, поскольку возможны обратные переключения.

\subsection{Алгоритмы защиты}\label{CRYPTO.SM.Algs}

\subsubsection{Входные и выходные данные, переменные}
\label{CRYPTO.SM.Algs.InOut}

Входными данными алгоритма установки защиты являются заголовок~$I\in\{0,1\}^{8*}$, 
критическое сообщение $X \in\{0,1\}^{8*}$, ключи~$K_1$, $K_2\in\{0,1\}^{256}$ 
и синхропосылка~$S\in\{0,1\}^{128}$. Выходными данными является кодовое 
представление~$\llangle I, Y, T \rrangle$ заголовка~$I$, 
зашифрованного сообщения~$Y\in\{0,1\}^{8*}$ и имитовставки~$T\in\{0,1\}^{64}$.

Входными данными алгоритма снятия защиты является кодовое представление 
$\llangle I,Y,T\rrangle$ заголовка~$I$, зашифрованного 
сообщения~$Y\in\{0,1\}^{8*}$ и имитовставки $T\in\{0,1\}^{64}$, а также 
ключи~$K_1$, $K_2\in\{0,1\}^{256}$ и синхропосылка~$S\in\{0,1\}^{128}$. 
Выходными данными является либо признак ошибки~$\perp$, либо первоначальное 
сообщение~$X\in\{0,1\}^{8*}$. Возврат~$\perp$ означает нарушение целостности 
или подлинности переданных данных.

Синхропосылки алгоритмов установки и снятия защиты строятся по правилам, 
определенным в~\ref{CRYPTO.SM.Ctr}. Правила кодирования выходных и 
промежуточных данных определены в~\ref{CMDS.SM}.

\subsubsection{Алгоритм установки защиты}
\label{CRYPTO.SM.Algs.Encr}

Алгоритм установки защиты состоит в выполнении шагов, определенных ниже.
При ошибке на любом из шагов алгоритм прекращается и возвращается признак 
ошибки~$\perp$.

\begin{enumerate}
\item
Установить $Y\gets\texttt{belt-cfb}(X, K_2, S)$.

\item
Выполнить кодирование $I$, $Y$ и построить их кодовое 
представление $\llangle I, Y\rrangle$.

\item
$T\gets\texttt{belt-mac}(S\parallel \llangle I, Y\rrangle, K_1)$.

\item
Выполнить кодирование $I$, $Y$, $T$ и построить их кодовое 
представление $\llangle I, Y, T \rrangle$.

\item
Возвратить $\llangle I, Y, T \rrangle$.
\end{enumerate}

\subsubsection{Алгоритм снятия защиты}
\label{CRYPTO.SM.Algs.Decr}

Алгоритм снятия защиты состоит в выполнении шагов, определенных ниже. При 
ошибке на любом из шагов, в том числе при отрицательном результате 
проверки, алгоритм прекращается и возвращается признак ошибки~$\perp$.

\begin{enumerate}
\item
Выполнить декодирование $\llangle I, Y, T \rrangle$ 
и определить $I$, $Y$, $T$.
 
\item
Выполнить кодирование $I$, $Y$ и построить их кодовое представление 
$\llangle I, Y \rrangle$.
 
\item
Проверить, 
что $T=\texttt{belt-mac}(S\parallel \llangle I, Y\rrangle, K_1)$.
 
\item
$X\leftarrow\texttt{belt-cfb}^{-1}(Y, K_2, S)$.
 
\item
Возвратить $X$.
\end{enumerate}

